# useHeroCarousel

Композабл для управления Hero-каруселью с автоматической прокруткой, навигацией и индикатором прогресса.

## Назначение

Этот composable инкапсулирует всю логику управления каруселью слайдов в Hero-секции лендинга. Он предоставляет реактивное состояние, методы навигации, автоматическую прокрутку с визуальным индикатором прогресса и обработку клавиатурного ввода. Основная идея заключается в том, чтобы отделить сложную логику управления каруселью от компонентов представления, делая код более модульным, тестируемым и переиспользуемым.

## Сигнатура

```typescript
function useHeroCarousel<T>(
  slides: Ref<T[]>,
  options?: UseHeroCarouselOptions,
): UseHeroCarouselReturn<T>;
```

## Параметры

### slides

- **Тип:** `Ref<T[]>`
- **Обязательный:** Да
- **Описание:** Реактивная ссылка на массив слайдов. Использование дженерика позволяет работать с любым типом данных слайдов, обеспечивая полную типобезопасность.

### options

- **Тип:** `UseHeroCarouselOptions`
- **Обязательный:** Нет
- **Описание:** Объект с настройками поведения карусели. Все параметры опциональны и имеют разумные значения по умолчанию.

#### Свойства options

**autoplay**

- **Тип:** `boolean`
- **По умолчанию:** `true`
- **Описание:** Включает или отключает автоматическую прокрутку слайдов. При значении `false` карусель управляется только вручную через методы навигации или клавиатуру.

**autoplayInterval**

- **Тип:** `number`
- **По умолчанию:** `5000`
- **Описание:** Интервал между автоматическими переключениями слайдов в миллисекундах. Значение 5000 означает, что каждый слайд будет показываться пять секунд перед переходом к следующему.

**transitionDuration**

- **Тип:** `number`
- **По умолчанию:** `1000`
- **Описание:** Длительность анимации перехода между слайдами в миллисекундах. Это время используется для блокировки повторных переключений во время анимации, предотвращая накопление команд и сбои в синхронизации.

## Возвращаемое значение

Composable возвращает объект с реактивными значениями и методами управления каруселью.

### currentIndex

- **Тип:** `Ref<number>`
- **Описание:** Реактивный индекс текущего активного слайда. Значение изменяется от нуля до количества слайдов минус один и циклически возвращается к нулю.

### isAnimating

- **Тип:** `Ref<boolean>`
- **Описание:** Флаг, указывающий на то, что в данный момент происходит анимация перехода между слайдами. Используется для блокировки множественных переключений, которые могут вызвать визуальные артефакты или рассинхронизацию.

### autoplayProgress

- **Тип:** `Ref<number>`
- **Описание:** Прогресс до следующего автоматического переключения в диапазоне от нуля до единицы. Это значение обновляется через requestAnimationFrame, обеспечивая плавную анимацию индикатора прогресса. При значении ноль прогресс только начался, при единице произойдёт переключение слайда.

### orderedSlides

- **Тип:** `ComputedRef<Array<{ slide: T; originalIndex: number }>>`
- **Описание:** Вычисляемое свойство, возвращающее слайды в порядке отображения. Массив циклически сдвигается так, что текущий активный слайд всегда находится на первой позиции (position zero), следующий на второй и так далее. Каждый элемент содержит сам слайд и его исходный индекс в оригинальном массиве, что необходимо для правильной работы с ключами в v-for. Этот подход позволяет управлять порядком отображения без физического перемещения DOM-элементов, оставляя эту работу системе виртуального DOM.

### next()

- **Тип:** `() => void`
- **Описание:** Метод для перехода к следующему слайду. При достижении конца массива циклически возвращается к первому слайду. Метод автоматически сбрасывает прогресс автопрокрутки и устанавливает флаг анимации на время, указанное в transitionDuration. Если анимация уже идёт или массив слайдов пуст, метод игнорирует вызов.

### prev()

- **Тип:** `() => void`
- **Описание:** Метод для перехода к предыдущему слайду. При нахождении на первом слайде циклически переходит к последнему. Поведение аналогично методу next в плане управления анимацией и проверок.

### pauseAutoplay()

- **Тип:** `() => void`
- **Описание:** Приостанавливает автоматическую прокрутку без полной остановки таймеров. Это полезно для временной паузы, например, при наведении курсора мыши на карусель. Таймер продолжает работать, но проверка флага паузы предотвращает фактическое переключение слайдов.

### resumeAutoplay()

- **Тип:** `() => void`
- **Описание:** Возобновляет автоматическую прокрутку после паузы. При возобновлении прогресс сбрасывается, чтобы пользователь получил полный интервал времени для просмотра текущего слайда, а не остаток от предыдущего цикла.

## Принцип работы

### Циклическая перестановка слайдов

Вместо физического перемещения DOM-элементов при каждом переключении слайда, composable использует элегантный подход с циклической перестановкой массива. Вычисляемое свойство orderedSlides создаёт новый массив, в котором слайды расположены так, что текущий активный слайд всегда находится на первой позиции. Это достигается через модульную арифметику: для каждой позиции в результирующем массиве вычисляется соответствующий индекс в исходном массиве по формуле `(currentIndex + i) % total`. Такой подход позволяет CSS-стилям, использующим data-атрибут position, правильно позиционировать элементы без необходимости манипулировать DOM напрямую.

### Управление прогрессом через requestAnimationFrame

Индикатор прогресса обновляется не через setInterval, а через requestAnimationFrame, что является best practice для создания плавных анимаций в браузере. Функция updateProgress рекурсивно вызывает сама себя через requestAnimationFrame, вычисляя прогресс на основе разницы между текущим временем и моментом начала отсчёта. Браузер сам оптимизирует частоту вызовов в зависимости от частоты обновления экрана, загрузки системы и видимости вкладки. Если карусель находится на неактивной вкладке, браузер автоматически снижает частоту обновлений или приостанавливает их полностью, экономя ресурсы процессора и батареи.

### Блокировка множественных переключений

Флаг isAnimating играет критически важную роль в предотвращении проблем с синхронизацией. Когда пользователь быстро кликает по кнопкам навигации или многократно нажимает стрелки на клавиатуре, без блокировки могут накопиться множественные команды переключения, что приведёт к пропуску слайдов или визуальным артефактам. Установка флага в true на время transitionDuration заставляет методы next и prev игнорировать новые вызовы до завершения текущей анимации. Это гарантирует, что в каждый момент времени происходит не более одного перехода.

### Обработка клавиатурного ввода

Обработчик handleKeydown добавляется к объекту window при монтировании компонента и удаляется при размонтировании, следуя правилам управления lifecycle в Vue. Это позволяет пользователям управлять каруселью с клавиатуры, что особенно важно для доступности. При нажатии стрелки влево или вправо происходит соответствующее переключение слайда, после чего автопрокрутка временно приостанавливается и возобновляется через полный интервал autoplayInterval. Такое поведение даёт пользователю время рассмотреть выбранный слайд, не заставляя его бороться с автоматическим переключением.

## Примеры использования

### Базовое использование

```typescript
import { ref } from "vue";
import { useHeroCarousel } from "@/composables/useHeroCarousel";
import type { Slide } from "@/types/heroSlideItem";

// Подготовка данных слайдов
const slides = ref<Slide[]>([
  {
    title: "Первый слайд",
    name: "Название",
    description: "Описание первого слайда",
    image: "slide1.jpg",
    btn: { text: "Подробнее", link: "/about" },
  },
  {
    title: "Второй слайд",
    name: "Заголовок",
    description: "Описание второго слайда",
    image: "slide2.jpg",
    btn: { text: "Узнать больше", link: "/services" },
  },
]);

// Инициализация карусели с настройками по умолчанию
const { currentIndex, orderedSlides, next, prev, autoplayProgress } =
  useHeroCarousel(slides);
```

В этом примере создаётся простейшая карусель с двумя слайдами и настройками по умолчанию. Автопрокрутка включена, интервал составляет пять секунд, длительность перехода одну секунду. Все возвращаемые значения и методы становятся доступны для использования в компоненте.

### Настройка параметров автопрокрутки

```typescript
const { orderedSlides, next, prev, pauseAutoplay, resumeAutoplay } =
  useHeroCarousel(slides, {
    autoplay: true,
    autoplayInterval: 8000, // Увеличиваем интервал до 8 секунд
    transitionDuration: 1500, // Замедляем анимацию до 1.5 секунд
  });
```

Здесь мы создаём более медленную карусель, где каждый слайд показывается восемь секунд, а переход занимает полторы секунды. Это может быть полезно для слайдов с большим количеством текста, который пользователю нужно успеть прочитать.

### Отключение автопрокрутки

```typescript
const { currentIndex, orderedSlides, next, prev } = useHeroCarousel(slides, {
  autoplay: false,
});

// Теперь карусель управляется только вручную через кнопки или клавиатуру
```

При отключенной автопрокрутке карусель становится полностью ручной. Это полезно для галерей изображений или ситуаций, где автоматическое переключение может раздражать пользователей. Прогресс-бар в этом случае не будет обновляться, так как нет автоматического таймера.

### Использование с provide/inject

```typescript
import { provide } from "vue";
import { HERO_CAROUSEL_KEY } from "@/keys/heroCarouselKeys";

const carousel = useHeroCarousel(slides);

// Предоставляем методы управления для дочерних компонентов
provide(HERO_CAROUSEL_KEY, {
  next: carousel.next,
  prev: carousel.prev,
  pauseAutoplay: carousel.pauseAutoplay,
  resumeAutoplay: carousel.resumeAutoplay,
  autoplayProgress: carousel.autoplayProgress,
});
```

Этот паттерн используется в родительском компоненте HeroSection для предоставления методов управления каруселью дочерним компонентам без необходимости прокидывать их через пропсы на каждом уровне вложенности.

### Интеграция с интерактивными элементами

```vue
<template>
  <div
    class="hero-container"
    @mouseenter="pauseAutoplay"
    @mouseleave="resumeAutoplay"
  >
    <div class="carousel">
      <div
        v-for="({ slide, originalIndex }, position) in orderedSlides"
        :key="originalIndex"
        :data-position="position"
        class="slide"
      >
        <h2>{{ slide.title }}</h2>
        <p>{{ slide.description }}</p>
      </div>
    </div>

    <div class="controls">
      <button @click="prev">←</button>
      <button @click="next">→</button>
    </div>

    <div class="progress-indicator">
      <div
        class="progress-fill"
        :style="{ width: `${autoplayProgress * 100}%` }"
      />
    </div>
  </div>
</template>
```

Здесь показан полноценный пример интеграции в шаблон компонента. При наведении курсора на контейнер автопрокрутка приостанавливается, при уходе курсора возобновляется. Кнопки навигации вызывают соответствующие методы, а прогресс-бар визуализирует значение autoplayProgress.

## Типы

### UseHeroCarouselOptions

```typescript
interface UseHeroCarouselOptions {
  autoplay?: boolean;
  autoplayInterval?: number;
  transitionDuration?: number;
}
```

Интерфейс опций конфигурации карусели. Все свойства опциональны, что позволяет передавать только те настройки, которые нужно изменить по сравнению с значениями по умолчанию.

### UseHeroCarouselReturn

```typescript
interface UseHeroCarouselReturn<T> {
  currentIndex: Ref<number>;
  isAnimating: Ref<boolean>;
  autoplayProgress: Ref<number>;
  orderedSlides: ComputedRef<Array<{ slide: T; originalIndex: number }>>;
  next: () => void;
  prev: () => void;
  pauseAutoplay: () => void;
  resumeAutoplay: () => void;
}
```

Интерфейс возвращаемого значения composable. Использование дженерика T обеспечивает типобезопасность: тип слайдов в orderedSlides будет соответствовать типу, переданному в параметре slides.

## Особенности реализации

### Управление таймерами

Composable использует два различных механизма для управления временем: setInterval для автопрокрутки и requestAnimationFrame для обновления прогресса. Это разделение обусловлено разными требованиями: setInterval обеспечивает точное срабатывание переключения слайдов через заданный интервал, в то время как requestAnimationFrame обеспечивает плавную визуальную анимацию индикатора прогресса, синхронизированную с частотой обновления экрана.

При размонтировании компонента оба таймера корректно очищаются в хуке onUnmounted, что предотвращает утечки памяти. Это особенно важно в одностраничных приложениях, где компоненты могут монтироваться и размонтироваться множество раз в течение сеанса работы пользователя.

### Реактивность и вычисляемые свойства

Использование computed для orderedSlides означает, что массив будет пересчитываться только при изменении currentIndex или самого массива slides. Vue автоматически отслеживает зависимости и кеширует результат, избегая ненужных вычислений. Это важно для производительности, так как функция вызывается при каждом рендере компонента.

### Типобезопасность с дженериками

Использование TypeScript дженериков позволяет composable работать с любым типом данных слайдов, сохраняя при этом полную типобезопасность. Компилятор TypeScript будет знать точный тип slide внутри orderedSlides на основе типа, переданного в параметре slides, и предупредит о попытках доступа к несуществующим свойствам.

## Рекомендации по использованию

При работе с этим composable рекомендуется всегда передавать реактивную ссылку на массив слайдов, даже если данные статичны. Это обеспечивает консистентность API и позволяет в будущем легко добавить динамическую загрузку слайдов без изменения логики.

Если вам нужно изменить настройки карусели динамически во время работы приложения, помните, что опции передаются только при инициализации. Для динамического управления используйте методы pauseAutoplay и resumeAutoplay, а также напрямую изменяйте возвращаемые реактивные значения через их API.

При интеграции с CSS-анимациями убедитесь, что значение transitionDuration соответствует длительности ваших CSS-переходов. Это гарантирует, что блокировка переключений будет снята именно в тот момент, когда визуальная анимация завершится.

Для улучшения доступности рекомендуется добавить к контейнеру карусели соответствующие ARIA-атрибуты, а также обеспечить видимость информации о текущем слайде для скринридеров. Клавиатурная навигация уже реализована, но её можно расширить, добавив поддержку клавиш Home и End для перехода к первому и последнему слайду соответственно.

## Известные ограничения

Текущая реализация не учитывает изменение видимости вкладки браузера через Page Visibility API. Автопрокрутка продолжает работать даже когда пользователь переключился на другую вкладку, хотя requestAnimationFrame автоматически снижает частоту обновлений в таких случаях. Для более эффективного управления ресурсами рекомендуется добавить обработку событий visibilitychange.

Composable не предоставляет встроенной поддержки свайпов для мобильных устройств. Управление ограничено кнопками навигации и клавиатурой. Для полноценной мобильной поддержки потребуется интеграция с библиотекой обработки touch-событий или написание собственных обработчиков.

При большом количестве слайдов (более десяти) рекомендуется оптимизировать загрузку изображений, используя ленивую загрузку. Composable не управляет загрузкой ресурсов, оставляя эту ответственность компонентам отображения.
