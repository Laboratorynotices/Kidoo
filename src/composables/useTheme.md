# useTheme

Композабл для управления многопалитровой системой тем в Vue.js приложении с поддержкой автоматического сохранения пользовательских предпочтений.

## Обзор

Композабл `useTheme` предоставляет централизованное решение для работы с различными цветовыми темами приложения. Он разработан для проектов, которым требуется поддержка нескольких тематических режимов, таких как детский, семейный и родительский интерфейсы, каждый из которых может работать как в светлом, так и в тёмном режиме.

Основная идея композабла заключается в управлении атрибутом `data-theme` корневого HTML-элемента, который затем используется в CSS-селекторах для применения соответствующих стилей. Это позволяет создавать гибкую систему тем без необходимости перезагрузки страницы или сложных манипуляций с DOM.

## Импорт и использование

```typescript
import { useTheme } from "@/composables/useTheme";

// Получение методов композабла
const { setTheme, initTheme, getStoredTheme } = useTheme();
```

## Типы данных

Композабл работает с типом `BodyMode`, который определяет доступные тематические режимы:

```typescript
type BodyMode = "kid" | "family" | "parent";
```

Каждый режим представляет определённую целевую аудиторию и имеет свою уникальную цветовую палитру. Семейный режим (`family`) является базовым и не требует установки дополнительных атрибутов, что упрощает CSS-селекторы и снижает их специфичность.

## API методы

### setTheme(type: BodyMode): void

Основной метод для переключения тематического режима приложения. Этот метод выполняет комплексную операцию по изменению темы, которая включает в себя несколько важных этапов.

**Параметры:**

- `type` (BodyMode) — тип темы для применения

**Алгоритм работы:**

Первым шагом метод получает ссылку на корневой элемент документа через `document.documentElement`. Это обеспечивает прямой доступ к элементу `<html>`, который служит основой для каскадного применения стилей всего приложения.

Далее происходит очистка предыдущих настроек темы путём удаления атрибута `data-theme`. Этот шаг критически важен для предотвращения конфликтов между различными тематическими режимами и обеспечения чистого состояния перед применением новой темы.

Следующий этап включает условную установку нового атрибута. Для режимов `kid` и `parent` устанавливается соответствующий атрибут `data-theme`, в то время как для семейного режима атрибут не устанавливается. Такой подход позволяет использовать семейную тему как базовую, что упрощает CSS-архитектуру и делает её более предсказуемой.

Заключительным этапом является сохранение выбора пользователя в локальном хранилище браузера. Это гарантирует, что при следующем посещении приложения тема будет восстановлена автоматически, что значительно улучшает пользовательский опыт.

**Пример использования:**

```typescript
// Переключение на детскую тему
setTheme("kid");

// Переключение на родительскую тему
setTheme("parent");

// Возврат к базовой семейной теме
setTheme("family");
```

### initTheme(): void

Метод инициализации темы, предназначенный для восстановления пользовательских предпочтений при загрузке приложения. Этот метод особенно важен для обеспечения непрерывности пользовательского опыта между сессиями.

**Алгоритм работы:**

Метод начинает с извлечения сохранённых настроек из локального хранилища через внутренний вызов `getStoredTheme()`. Если в хранилище обнаружены валидные данные о ранее выбранной теме, они автоматически применяются через вызов `setTheme()`.

В случае отсутствия сохранённых данных (например, при первом посещении сайта или после очистки хранилища), метод корректно завершает работу без выполнения дополнительных действий. Это означает, что приложение будет использовать базовую тему, определённую в CSS.

**Рекомендуемое размещение:**

```typescript
import { onMounted } from "vue";

onMounted(() => {
  initTheme();
});
```

Размещение вызова `initTheme()` в хуке `onMounted` гарантирует, что DOM полностью сформирован и готов к манипуляциям с атрибутами. Это предотвращает потенциальные ошибки, связанные с попытками доступа к несуществующим элементам.

### getStoredTheme(): BodyMode | null

Вспомогательный метод для получения информации о сохранённой в локальном хранилище теме. Он предоставляет возможность программного доступа к пользовательским предпочтениям без их немедленного применения.

**Возвращаемые значения:**

- `BodyMode` — если в хранилище найдена валидная тема
- `null` — если данные отсутствуют или повреждены

**Внутренняя логика:**

Метод выполняет простое извлечение данных из localStorage по ключу, определённому во внутренней константе `STORAGE_KEY`. Полученная строка приводится к типу `BodyMode | null` через type assertion, что обеспечивает совместимость с TypeScript системой типов.

**Пример использования:**

```typescript
const currentTheme = getStoredTheme();

if (currentTheme) {
  console.log(`Текущая сохранённая тема: ${currentTheme}`);
} else {
  console.log("Сохранённая тема не найдена");
}
```

## Интеграция с CSS

Для корректной работы композабла требуется соответствующая настройка CSS-стилей с использованием пользовательских вариантов Tailwind CSS:

```css
@variant kid ([data-theme="kid"] &);
@variant parent ([data-theme="parent"] &);
```

Эти директивы создают модификаторы `kid:` и `parent:`, которые активируются при наличии соответствующих атрибутов `data-theme`. Такой подход позволяет создавать сложные комбинированные селекторы, например `kid:dark:bg-background-kid-primary-dark` для детской темы в тёмном режиме.

## Архитектурные особенности

### Принцип единственной ответственности

Каждый метод композабла выполняет строго определённую задачу. Такое разделение ответственности упрощает тестирование, отладку и дальнейшую поддержку кода. Метод `setTheme` отвечает исключительно за применение темы, `getStoredTheme` — за извлечение данных, а `initTheme` — за инициализацию.

### Инкапсуляция внутренней логики

Константа `STORAGE_KEY` определена внутри композабла и недоступна извне. Это предотвращает случайные конфликты в локальном хранилище и обеспечивает чистоту публичного API. При необходимости изменения ключа хранения потребуется модификация только одного места в коде.

### Безопасность типов

Использование TypeScript типизации предотвращает передачу невалидных значений в методы композабла. Это особенно важно при работе с данными из localStorage, которые могут быть изменены внешними скриптами или пользователем.

## Примеры использования

### Базовая интеграция в компонент

```vue
<script setup lang="ts">
import { onMounted } from "vue";
import { useTheme } from "@/composables/useTheme";

const { setTheme, initTheme } = useTheme();

onMounted(() => {
  initTheme();
});
</script>

<template>
  <div class="theme-switcher">
    <button
      @click="setTheme('kid')"
      class="kid:bg-kid-primary parent:bg-parent-primary"
    >
      Детская тема
    </button>

    <button @click="setTheme('family')" class="bg-primary text-primary">
      Семейная тема
    </button>

    <button
      @click="setTheme('parent')"
      class="parent:bg-parent-primary kid:bg-kid-primary"
    >
      Родительская тема
    </button>
  </div>
</template>
```

### Программное определение текущей темы

```vue
<script setup lang="ts">
import { computed } from "vue";
import { useTheme } from "@/composables/useTheme";

const { getStoredTheme } = useTheme();

const currentThemeLabel = computed(() => {
  const theme = getStoredTheme();

  switch (theme) {
    case "kid":
      return "Детский режим";
    case "parent":
      return "Родительский режим";
    case "family":
      return "Семейный режим";
    default:
      return "Тема не выбрана";
  }
});
</script>

<template>
  <div class="current-theme-indicator">
    <p>Активная тема: {{ currentThemeLabel }}</p>
  </div>
</template>
```

## Рекомендации по расширению

### Добавление новых тем

Для добавления дополнительных тематических режимов потребуется:

1. Расширить тип `BodyMode` в файле типов
2. Добавить соответствующие CSS-переменные и варианты
3. Обновить логику в методе `setTheme` при необходимости специальной обработки

### Валидация данных хранилища

Рекомендуется добавить валидацию для данных, извлекаемых из localStorage:

```typescript
const getStoredTheme = (): BodyMode | null => {
  const stored = localStorage.getItem(STORAGE_KEY);
  const validThemes: BodyMode[] = ["kid", "family", "parent"];

  return stored && validThemes.includes(stored as BodyMode)
    ? (stored as BodyMode)
    : null;
};
```

## Ограничения и соображения

Композабл предполагает наличие поддержки localStorage в браузере. В средах, где это API недоступно, потребуется дополнительная обработка ошибок или альтернативные методы сохранения настроек.

Текущая реализация не включает механизмы синхронизации между вкладками браузера. Если пользователь изменит тему в одной вкладке, другие вкладки не обновятся автоматически до перезагрузки.
